# **Scoping and the Scope Chain**

In this section we will talk about the second step, the creation of the `Scope Chain`. Scoping is basically
where we can access a certain variable or function. In JavaScript, each function creates a scope which is an environment
in which the variables that it defines are accessible.

In many other programming languages, a scope is also created by `if` blocks or `for` blocks, for example, but not in
JavaScript prior to ES6. In JavaScript (ES5) the only way that we have to create a new scope is to write a new function, and this is something very
important to understand.

In JavaScript we have `lexical scoping`, which _basically_ means, where something is written in the code. It's about the position
of something _within_ the code. It means a function that is lexically within another function gets access to the scope of the outer function.

But before that, we need to understand the difference between `var`, `let`, `const`, `function scope` and `block scope`.

## **`var` - `function scope`**

A variable being declared using `var` will be function scoped, meaning it will exist within the scope of the **function it's declared inside of**.

```js
function fn() {
  var name = "John";
  console.log(name); // expected output: John
}

fn();

console.log(name); // name is not defined
```

The variable declared with `var` inside the function is not reachable from outside the function. However, other types of blocks, like
`if` statements, `loops` etc, will not be considered as a scope.

```js
if (true) {
  var name = "John";
}

console.log(name); // expected output: John
```

using `var`, the variable `name` is available outside the `if` statement it was declared inside of. This happens because
they are in the same scope.

However, with the introduction of ES6, two new ways of declaring variables were introduced.

## **`let` and `const` - `block scopes`**

In ES6, `let` and `const` were introduced as alternative ways of declaring variables, both being `block scoped`.

In block scope, any block will be a scope, this will give you more consistent behavior, this means that a function
still is a valid scope just like with `var`.

```js
function fn() {
  const name = "John";
  console.log(name); // expected output: John
}

fn();

console.log(name); // name is not defined
```

```js
if (true) {
  let name = "John";
}

console.log(name); // name is not defined
```

## **Scope Chain Examples**

Thanks to lexical scoping, the scope of `secondFn` has access to it's parents scope and all the variables,
and the scope of `firstFn` has access to the global scope and all the variables.

So `secondFn` can log `a` and `b` even though that we never declared those variables inside of `secondFn`.

This goes all the way up from the bottom scope to the global scope, and this is exactly called the `Scope Chain`.

Only if the JavaScript engine does not find a variable anywhere it throws an error and stops execution.

```js
////////////////////////////////////////             ////////////////////////////                 /\
var a = "a";                          //             //      Global Scope      //                 || s
firstFn();                            //-----------> //      [VO Global]       //                 || c
                                      //             ////////////////////////////                 || o
                                      //                                                          || p
function firstFn() {                  //                                                          || e
//////////////////////////////////    //             //////////////////////////////////           ||
  var b = "b";                  // ----------------> // 1  //    firstFn() scope     //           || c
  secondFn();                   //    //             ////////  [VO 1] + [VO global]  //           || h
                                //    //             //////////////////////////////////           || a
  function secondFn() {         //    //                                                          || i
/////////////////////////////   //    //                                                          || n
    var c = "c";           //----------------------> //////////////////////////////////////////   ||
    console.log(a + b + c) //   //    //             // 2 //        secondFn() scope         //   ||
/////////////////////////////   //    //             ///////  [VO 2] + [VO 1] + [VO global]  //   ||
  }                             //    //             //////////////////////////////////////////   ||
//////////////////////////////////    //
}                                     //
////////////////////////////////////////
```

It's important to understand that this does not work backwards. For example, the global scope will never have access to 
the variables `b` or `c` unless we return the values from the functions.

Locally scoped variables are not visible to their parents scopes, the scope chain is always upwards. 