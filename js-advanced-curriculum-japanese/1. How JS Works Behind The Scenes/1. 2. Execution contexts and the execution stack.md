# **Execution Contexts and the execution Stack**

In this lesson we will focus on the order in which the code is run. And for this we need to understand about the execution
contexts. All JavaScript code needs to run in an environment, and these environments are called execution contexts; you can
imagine an execution context like a container, which stores variables and a piece of our code that is evaluated and executed.

The default execution context is always the `global context`, in a global context all the code that is not inside a function
is executed, that means that the global context is for any variable or functions outside of a function.
You can think of an execution context as an `object`, the global context is associated with the `global object`, which in the
case of a browser, is the `window object`. So everything that we declare in the global context, automatically gets attached
to the `window` object in the browser. Declaring a variable called `myName` and `window.myName` is the exact same thing.

### **But what about code that is in functions?**

Each time we call a function, it gets its own brand-new execution context.

### **Example:**

```js
// This is not in any function, meaning that this in the global context
const name = "John Doe";

// This is not in any function, meaning that this in the global context
function sayHi() {
  const greeting = "Hi"; // 2. Stored in the first execution context
  sayHello(); // 3. Creates the second execution context
  console.log(`${greeting} ${name}`); // 9. Since the second context is completed
  // we return to this context, and log this in the first execution context

  // There is nothing else to happen in this function, so this execution context
  // is completed and removed from the stack
}

// This is not in any function, meaning that this in the global context
function sayHello() {
  const greeting = "Hello"; // 4. Stored in the second execution context
  sayHowdy(); // 5. Creates the third execution context
  console.log(`${greeting} ${name}`); // 8. Since the third context is completed
  // we return to this context, and log this in the second execution context

  // There is nothing else to happen in this function, so this execution context
  // is completed and removed from the stack, returning to the previous context
}

// This is not in any function, meaning that this in the global context
function sayHowdy() {
  const greeting = "Howdy"; // 6. Stored in the third execution context
  console.log(`${greeting} ${name}`); //7. Log this the third execution context

  // There is nothing else to happen in this function, so this execution context
  // is completed and removed from the stack, returning to the previous context
}

sayHi(); // 1. Creates the first execution context
```
