# **Downsides of `async`/`await`**

`async`/`await` makes our code looks synchronous, and it does behave more synchronously. The `await` keyword blocks
execution of all the code that follows until the promise fulfills. It does allow other tasks to continue to run in
the same time, but our own code is blocked.

This means that our code could be slowed down by a significant number of awaited promises happening after one another.
Each `await` will wait for the previous one to finish, when what we actually want is for the promises to begin
processing simultaneously, like they would do if we weren't using `async`/`await`

There is a pattern to mitigate this problem, we can set off all the promise processes by storing the `Promise` object
in variables, and then awaiting them afterwards:

```js
const delay = interval =>
  new Promise(resolve =>
    setTimeout(() => {
      console.log("done");
      resolve();
    }, interval)
  );

const test = async () => {
  await delay(3000);
  await delay(3000);
  await delay(3000);
};

test();
```

This will await all three `delay()` calls directly, making each one wait 3 seconds.

We can mitigate this by following this pattern:

```js
const delay = interval =>
  new Promise(resolve =>
    setTimeout(() => {
      console.log("done");
      resolve();
    }, interval)
  );

const test = async () => {
  const firstDelay = delay(3000);
  const secondDelay = delay(3000);
  const thirdDelay = delay(3000);

  await firstDelay;
  await secondDelay;
  await thirdDelay;
};

test();
```

Since the promises all started processing at essentially the same time, they will fulfill at the same time, so we can await their results.

