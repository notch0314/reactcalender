# **Reflect**

Reflection is a branch of meta programming. Reflection has three sub branches:

- Introspection: The code is able to inspect itself
- Self-modification: The code is able to modify itself
- Intercession: Acting on behalf of somebody else

In `ES6`, the Reflect is a new Global Object, that provides a number of utility functions, many of which appear
to overlap with `ES5` methods defined on the global Object. All these functions are Introspection functions
where you could query some internal details about the program at the run time.

JavaScript already had been supporting APIs for object reflection, but these APIs were not organized under a namespace.
Since `ES6`, those are under Reflect.

Reflect is not a constructor, we cannot use it with a new operator or invoke the Reflect object as a function. All
properties and methods of Reflect are static like the Math object.

The Introspection methods on Object throw exceptions when they fail to complete the operation. This is an added burden
to the programmer to handle that exception in code.

For example:

```js
try {
  Object.defineProperty(obj, name, description);
  // property defined successfully
} catch (error) {
  // failure
}
```

And using the Reflect API:

```js
if (Reflect.defineProperty(obj, name, description)) {
  // success
} else {
  // failure
}
```

In `ES5`, the way we would find the existence of a property for an Object is `(prop in obj)`, with the Reflect API
we can use `Reflect.has(obj, prop)`.

We also have more reliability in the `Function apply`: In `ES5` the most reliable way of calling a function with a
variable number of arguments as an array, and binding the `this` value to `obj`:

```js
func.apply(obj, array);
```

This is less reliable because `func` could be an object that would have defined it's own `apply`

In `ES6` we have a more reliable way to solve this:

```js
Reflect.apply(func, obj, array);
```

We can also use the Reflect API to `Proxy Trap Forward`. When we use the Proxy object to wrap the existing object, we
commonly intercept an operation:

```js
const handler = {
  get(target, fieldName) {
    console.log("Log:", target[fieldName]);
    return Reflect.get(target, fieldName);
  }
};

const person = {
  firstName: "John",
  lastName: "Doe"
};

const fn = () => {
  const personProxy = new Proxy(person, handler);
  personProxy.firstName;
  personProxy.lastName;
};

fn();

/*
  expected output:
    Log: John
    Log: Doe
*/
```
